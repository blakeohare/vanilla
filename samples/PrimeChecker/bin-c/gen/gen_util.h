#ifndef _VANILLA_GENERATED_UTIL_H
#define _VANILLA_GENERATED_UTIL_H

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef struct _Value {
	char type;
	int anchors;
} Value;

typedef struct _ValueInt {
	Value _valueHeader;
	int value;
} ValueInt;

typedef struct _ValueFloat {
	Value _valueHeader;
	double value;
} ValueFloat;

typedef struct _ValueString {
	Value _valueHeader;
	int length;
	int hash;
	char* c_string;
	int* unicode_points;
} ValueString;

typedef struct _ValueBoolean {
	Value _valueHeader;
	int value;
} ValueBoolean;

typedef struct _ValueList {
	Value _valueHeader;
	int size;
	int capacity;
	Value** items;
} ValueList;

typedef struct _ValueArray {
	Value _valueHeader;
	int size;
	Value** items;
} ValueArray;

typedef struct _MapNode {
	int hash;
	Value* key;
	Value* value;
	struct _MapNode* next;
} MapNode;

typedef struct _ValueMap {
	Value _valueHeader;
	int is_string_key;
	int size;
	int bucket_size;
	MapNode** buckets;
} ValueMap;

typedef struct _GCBucket {
	Value* current;
	struct _GCBucket* prev;
	struct _GCBucket* next;
} GCBucket;


typedef struct _VContext {
	int initialized;
	Value* global_true;
	Value* global_false;
	Value* global_zero;
	Value* global_one;
	Value* global_float_zero;
	Value* global_float_one;
	Value** global_int_pos;
	Value** global_int_neg;
	Value* global_empty_string;
	Value** string_table;
	Value** string_single_char;
	ValueInt* mru_int;

	GCBucket* gc_universe;
} VContext;



Value* vutil_gc_create_new_value(VContext* vctx, char value_type, int sizeof_value) {
	GCBucket* bucket = (GCBucket*)malloc(sizeof(GCBucket));
	bucket->current = (Value*)malloc(sizeof_value);
	bucket->current->type = value_type;
	GCBucket* next = vctx->gc_universe; // universe is initialized with numerous globals so 2+ linked list nodes are guaranteed.
	GCBucket* prev = next->prev; // universe is a circularly linked list
	bucket->prev = prev;
	bucket->next = next;
	prev->next = bucket;
	next->prev = bucket;
	return bucket->current;
}

Value* vutil_get_boolean(VContext* vctx, int value) {
	if (value == 0) return vctx->global_false;
	return vctx->global_true;
}

Value* vutil_get_int(VContext* vctx, int value) {
	if (value < 1024 && value > -1024) {
		if (value < 0) return vctx->global_int_neg[value];
		return vctx->global_int_pos[value];
	}

	if (vctx->mru_int->value == value) return (Value*)vctx->mru_int;

	ValueInt* new_int = (ValueInt*)vutil_gc_create_new_value(vctx, 'I', sizeof(ValueInt));
	new_int->value = value;
	return (Value*)new_int;
}

Value* vutil_get_float(VContext* vctx, double value) {
	// == comparison for floating point precision is accurate for whole numbers and okay to miss if off by a floating point error as this is just a cache miss
	if (value == 0) return vctx->global_float_zero;
	if (value == 1) return vctx->global_float_one;

	ValueFloat* new_float = (ValueFloat*)vutil_gc_create_new_value(vctx, 'F', sizeof(ValueFloat));
	new_float->value = value;
	return (Value*)new_float;
}

Value* vutil_get_string_from_chars(VContext* vctx, char* c_string) {
	if (c_string[0] == '\0') return vctx->global_empty_string;
	if (c_string[1] == '\0' && c_string[1] < 128) {
		return vctx->string_single_char[c_string[0]];
	}

	int size = 0;
	int capacity = 20;
	int* points = (int*)malloc(sizeof(int) * capacity);

	int b1, b2, b3, b4;

	// character strings will be generated by the transpiler and can be assumed to be valid UTF-8
	for (int i = 0; c_string[i] != '\0'; i++) {
		if (size == capacity) {
			int new_capacity = capacity * 2;
			int* new_points = (int*)malloc(sizeof(int) * new_capacity);
			for (int j = 0; j < new_capacity; ++j) {
				new_points[j] = points[j];
			}
			free(points);
			points = new_points;
			capacity = new_capacity;
		}
		b1 = c_string[i];
		if ((b1 & 0x80) == 0) {
			points[size] = b1;
		}
		else if ((b1 & 0xE0) == 0xC0) {
			b2 = c_string[i + 1];
			points[size] = ((b1 & 0x1F) << 6) | (b2 & 0x3F);
			i += 1;
		}
		else if ((b1 & 0xF0) == 0xE0) {
			b2 = c_string[i + 1];
			b3 = c_string[i + 2];
			points[size] = ((b1 & 0x0F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F);
			i += 2;
		}
		else if ((b1 & 0xF8) == 0xF0) {
			b2 = c_string[i + 1];
			b3 = c_string[i + 2];
			b4 = c_string[i + 3];
			points[size] = ((b1 & 0x07) << 18) | ((b2 & 0x3F) << 12) | ((b3 & 0x3F) << 6) | (b4 & 0x3F);
			i += 3;
		}
		size++;
	}

	if (size != capacity) {
		int* new_points = (int*)malloc(sizeof(int) * size);
		for (int i = 0; i < size; i++) {
			new_points[i] = points[i];
		}
		free(points);
		points = new_points;
	}

	int hash = 0;
	for (int i = 0; i < size; i++) {
		hash = hash * 37 + points[i];
	}

	ValueString* str = (ValueString*)vutil_gc_create_new_value(vctx, 'S', sizeof(ValueString));
	str->length = size;
	str->hash = hash;
	str->c_string = NULL;
	str->unicode_points = points;

	return (Value*)str;
}

VContext* vutil_initialize_context(int string_table_size) {
	VContext* vctx = (VContext*)malloc(sizeof(VContext));

	// The booleans need to be initialized manually as the initialization code
	// add new values to the Garbage Collection Universe, which makes a fast
	// assumption that at least 2 items already exist in the circularly linked
	// list.
	GCBucket* gc_bools[2];
	for (int i = 0; i < 2; i++) {
		ValueBoolean* b = (ValueBoolean*)malloc(sizeof(ValueBoolean));
		Value* vb = (Value*)b;
		vb->type = 'B';
		vb->anchors = 0;
		b->value = i;
		if (i == 1) vctx->global_true = vb;
		else vctx->global_false = vb;
		gc_bools[i] = malloc(sizeof(GCBucket));
		gc_bools[i]->current = vb;
	}
	gc_bools[0]->next = gc_bools[1];
	gc_bools[0]->prev = gc_bools[1];
	gc_bools[1]->next = gc_bools[0];
	gc_bools[1]->prev = gc_bools[0];
	vctx->gc_universe = gc_bools[0];

	Value** int_pos = (Value**)malloc(sizeof(ValueInt*) * 1024);
	Value** int_neg = (Value**)malloc(sizeof(ValueInt*) * 1024);
	for (int i = 0; i < 1024; i++) {
		int_pos[i] = vutil_gc_create_new_value(vctx, 'I', sizeof(ValueInt));
		((ValueInt*)int_pos[i])->value = i;
		if (i > 0) {
			int_neg[i] = vutil_gc_create_new_value(vctx, 'I', sizeof(ValueInt));
			((ValueInt*)int_neg[i])->value = -i;
		}
	}
	int_neg[0] = int_pos[0];
	vctx->global_int_pos = int_pos;
	vctx->global_int_neg = int_neg;
	vctx->global_zero = int_pos[0];
	vctx->global_one = int_pos[1];
	vctx->global_float_zero = vutil_gc_create_new_value(vctx, 'F', sizeof(ValueFloat));
	((ValueFloat*)vctx->global_float_zero)->value = 0.0;
	vctx->global_float_one = vutil_gc_create_new_value(vctx, 'F', sizeof(ValueFloat));
	((ValueFloat*)vctx->global_float_one)->value = 1.0;

	vctx->mru_int = (ValueInt*)vctx->global_zero;

	vctx->string_single_char = (Value**)malloc(sizeof(ValueString*) * 128);
	for (int i = 0; i < 128; i++) {
		ValueString* s = (ValueString*)vutil_gc_create_new_value(vctx, 'S', sizeof(ValueString));
		s->length = 1;
		s->hash = i;
		s->c_string = (char*)malloc(sizeof(char) * 2);
		s->c_string[0] = (char)i;
		s->c_string[1] = '\0';
		s->unicode_points = (int*)malloc(sizeof(int) * 1);
		s->unicode_points[0] = i;
		vctx->string_single_char[i] = (Value*)s;
	}
	vctx->global_empty_string = vctx->string_single_char[0];
	ValueString* empty_str = (ValueString*)vctx->global_empty_string;
	// The fact that the char arrays are over-allocated will have no ill-effects. This prevents the need for extra checks later.
	empty_str->length = 0;
	empty_str->hash = 1317; // randomize bucketing

	vctx->string_table = (Value**)malloc(sizeof(Value*) * string_table_size);
	return vctx;
}

Value* vutil_list_new(VContext* vctx) {
	ValueList* list = (ValueList*)vutil_gc_create_new_value(vctx, 'L', sizeof(ValueList));
	list->size = 0;
	list->capacity = 4;
	list->items = (Value**)malloc(sizeof(Value*) * 4);
	return (Value*)list;
}

int vutil_string_equals(ValueString* s1, ValueString* s2) {
	if (s1 == s2) return 1;
	if (s1->hash != s2->hash || s1->length != s2->length) return 0;
	int len = s1->length;
	int* p1 = s1->unicode_points;
	int* p2 = s2->unicode_points;
	for (int i = 0; i < len; i++) {
		if (p1[i] != p2[i]) return 0;
	}
	return 1;
}

MapNode* vutil_get_string_map_node(Value* vmap, Value* vkey, int create_if_missing) {
	ValueString* key = (ValueString*)vkey;
	ValueMap* map = (ValueMap*)vmap;
	int hashcode = key->hash;
	int bucketIndex = hashcode % map->bucket_size;
	if (bucketIndex < 0) bucketIndex += map->bucket_size;
	MapNode* head = map->buckets[bucketIndex];
	MapNode* walker = head;
	MapNode* target = NULL;
	while (walker != NULL) {
		if (walker->hash == hashcode && vutil_string_equals((ValueString*)walker->key, key)) {
			target = walker;
			break;
		}
		walker = walker->next;
	}

	if (target == NULL && create_if_missing) {
		// TODO: rehash if necessaryy
		target = (MapNode*)malloc(sizeof(MapNode));
		target->hash = hashcode;
		target->key = vkey;
		target->value = NULL;
		target->next = head;
		map->buckets[bucketIndex] = target;
		map->size++;
	}
	return target;
}

void vutil_map_set_str(Value* wm, Value* wk, Value* wv) {
	MapNode* node = vutil_get_string_map_node(wm, wk, 1);
	node->value = wv;
}

Value* vutil_list_clone(VContext* vctx, Value* voriginal) {
	ValueList* original = (ValueList*)voriginal;
	if (original->size == 0) return vutil_list_new(vctx);

	ValueList* list = (ValueList*)vutil_gc_create_new_value(vctx, 'L', sizeof(ValueList));
	int len = original->size;
	list->size = len;
	list->capacity = len;
	list->items = (Value**)malloc(sizeof(Value*) * len);
	Value** original_items = ((ValueList*)original)->items;
	for (int i = 0; i < len; i++) {
		list->items[i] = original_items[i];
	}
	return (Value*)list;
}

double vutil_sqrt(double value) {
	return sqrt(value);
}

Value* vutil_new_map(VContext* vctx, int is_string_key) {
	ValueMap* map = (ValueMap*)vutil_gc_create_new_value(vctx, 'M', sizeof(ValueMap));

	map->is_string_key = is_string_key;
	map->size = 0;
	map->bucket_size = 8;
	map->buckets = (MapNode**)malloc(sizeof(MapNode*) * map->bucket_size);
	for (int i = 0; i < map->bucket_size; i++) {
		map->buckets[i] = NULL;
	}

	return (Value*)map;
}

void vutil_list_add(VContext* vctx, Value* vlist, Value* item) {
	ValueList* list = (ValueList*)vlist;
	if (list->size == list->capacity) {
		int old_capacity = list->capacity;
		int new_capacity = old_capacity * 2 + 1;
		if (new_capacity < 10) new_capacity = 10;
		Value** new_items = (Value**)malloc(sizeof(Value*) * new_capacity);
		for (int i = 0; i < new_capacity; i++) {
			new_items[i] = i < old_capacity ? list->items[i] : NULL;
		}
		free(list->items);
		list->items = new_items;
		list->capacity = new_capacity;
	}

	list->items[list->size++] = item;
}

double vutil_safe_modf(double num, double div) {
	double result = fmod(num, div);
	if (result < 0) result += div;
	return result;
}

int vutil_safe_mod(int num, int div) {
	int result = num % div;
	if (result < 0) result += div;
	return result;
}

Value* vutil_get_map_string_value(Value* vmap, Value* key) {
	MapNode* node = vutil_get_string_map_node(vmap, key, 0);
	if (node == NULL) return NULL;
	return node->value;
}

Value** vutil_list_to_array(Value* vlist, int* size) {
	ValueList* list = (ValueList*)vlist;
	int len = list->size;
	if (size != NULL) *size = len;
	Value** arr = (Value**)malloc(sizeof(Value*) * len);
	for (int i = 0; i < len; i++) {
		arr[i] = list->items[i];
	}
	return arr;
}

int* vutil_list_to_int_array(Value* vlist, int* size) {
	int arrSize = 0;
	Value** values = vutil_list_to_array(vlist, &arrSize);
	if (size != NULL) *size = arrSize;
	int* arr = (int*)malloc(sizeof(int) * arrSize);
	for (int i = 0; i < arrSize; i++) {
		arr[i] = ((ValueInt*)values)->value;
	}
	free(values);
	return arr;
}

#endif // _VANILLA_GENERATED_UTIL_H
